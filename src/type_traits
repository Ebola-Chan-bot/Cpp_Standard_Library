/*	Copyright (C) 2005 Garrett A. Kajmowicz

    This file is part of the uClibc++ Library.
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#pragma once
#define __glibcxx_want_bool_constant
#define __glibcxx_want_bounded_array_traits
#define __glibcxx_want_is_invocable
#define __glibcxx_want_is_null_pointer
#define __glibcxx_want_is_swappable
#define __glibcxx_want_logical_traits
#define __glibcxx_want_transformation_trait_aliases
#define __glibcxx_want_type_trait_variable_templates
#include <bits/version.h>
#ifdef ARDUINO_ARCH_AVR
#include "char_traits"
#include "cstddef"
#else
#include_next <type_traits>
#endif
#ifndef ARDUINO_ARCH_ESP32
#include "xtr1common"
#endif
#pragma GCC visibility push(default)

namespace std
{
#ifdef ARDUINO_ARCH_AVR
    struct _UCXXEXPORT __true_type
    {
    };
    struct _UCXXEXPORT __false_type
    {
    };

    template <class I>
    class _UCXXEXPORT __is_integer
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __false_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<unsigned int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<signed int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<short unsigned int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<short signed int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<char>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<signed char>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<unsigned char>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<long unsigned int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };

    template <>
    class _UCXXEXPORT __is_integer<long signed int>
    {
    public:
        enum
        {
            __value = 1
        };
        typedef __true_type value;
    };
    template <class _Ty>
    struct is_void : is_same<remove_cv_t<_Ty>, void>
    {
    };
#endif
#ifdef ARDUINO_ARCH_SAM
    // Workaround SAM 平台的 void_t bug
    template <class... _Types>
    struct void_s
    {
        using type = void;
    };
    template <class T, class... _Types>
    struct void_s<T, _Types...>
    {
        using type = T;
    };
    template <typename... _Types>
    using void_t = typename void_s<_Types...>::type;
#else
    template <class... _Types>
    using void_t = void;
#endif
#ifdef ARDUINO_ARCH_AVR

    template <typename _Tp>
    class reference_wrapper;

    /**
     * @defgroup metaprogramming Metaprogramming
     * @ingroup utilities
     *
     * Template utilities for compile-time introspection and modification,
     * including type classification traits, type property inspection traits
     * and type transformation traits.
     *
     * @since C++11
     *
     * @{
     */

    /// integral_constant
    template <typename _Tp, _Tp __v>
    struct integral_constant
    {
        static constexpr _Tp value = __v;
        using value_type = _Tp;
        using type = integral_constant<_Tp, __v>;
        constexpr operator value_type() const noexcept { return value; }

#ifdef __cpp_lib_integral_constant_callable // C++ >= 14
        constexpr value_type operator()() const noexcept { return value; }
#endif
    };

#if !__cpp_inline_variables
    template <typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;
#endif
#endif
#ifndef ARDUINO_ARCH_ESP32
    /// @cond undocumented
    /// bool_constant for C++11
    template <bool __v>
    using __bool_constant = integral_constant<bool, __v>;
    /// @endcond

    /// The type used as a compile-time boolean with true value.
    using true_type = __bool_constant<true>;

    /// The type used as a compile-time boolean with false value.
    using false_type = __bool_constant<false>;

#ifdef __cpp_lib_bool_constant // C++ >= 17
    /// Alias template for compile-time boolean constant types.
    /// @since C++17
    template <bool __v>
    using bool_constant = __bool_constant<__v>;
#endif
// 122
#endif
#ifdef ARDUINO_ARCH_AVR
    // Metaprogramming helper types.

    // Primary template.
    /// Define a member typedef `type` only if a boolean constant is true.
    template <bool, typename _Tp = void>
    struct enable_if
    {
    };

    // Partial specialization for true.
    template <typename _Tp>
    struct enable_if<true, _Tp>
    {
        using type = _Tp;
    };

    // __enable_if_t (std::enable_if_t for C++11)
    template <bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    // 105
    template <class _Ty, class = void>
    struct _Add_reference
    { // add reference (non-referenceable type)
        using _Lvalue = _Ty;
        using _Rvalue = _Ty;
    };

    template <class _Ty>
    struct _Add_reference<_Ty, void_t<_Ty &>>
    { // (referenceable type)
        using _Lvalue = _Ty &;
        using _Rvalue = _Ty &&;
    };

    template <class _Ty>
    struct add_lvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Lvalue;
    };

    template <class _Ty>
    using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

    template <class _Ty>
    struct add_rvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Rvalue;
    };

    template <class _Ty>
    using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

    template <class _Ty>
    struct remove_extent
    { // remove array extent
        using type = _Ty;
    };

    template <class _Ty, size_t _Ix>
    struct remove_extent<_Ty[_Ix]>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_extent<_Ty[]>
    {
        using type = _Ty;
    };
#endif
    template <class _Ty>
    using remove_extent_t = typename remove_extent<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR
    // 156
    // 139
    template <bool>
    struct __conditional
    {
        template <typename _Tp, typename>
        using type = _Tp;
    };

    template <>
    struct __conditional<false>
    {
        template <typename, typename _Up>
        using type = _Up;
    };

    // More efficient version of std::conditional_t for internal use (and C++11)
    template <bool _Cond, typename _If, typename _Else>
    using __conditional_t = typename __conditional<_Cond>::template type<_If, _Else>;

    /// @cond undocumented
    template <typename _Type>
    struct __type_identity
    {
        using type = _Type;
    };

    template <typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

    namespace __detail
    {
        // A variadic alias template that resolves to its first argument.
        template <typename _Tp, typename...>
        using __first_t = _Tp;

        // These are deliberately not defined.
        template <typename... _Bn>
        auto __or_fn(int) -> __first_t<false_type,
                                       __enable_if_t<!bool(_Bn::value)>...>;

        template <typename... _Bn>
        auto __or_fn(...) -> true_type;

        template <typename... _Bn>
        auto __and_fn(int) -> __first_t<true_type,
                                        __enable_if_t<bool(_Bn::value)>...>;

        template <typename... _Bn>
        auto __and_fn(...) -> false_type;
    } // namespace detail

    // Like C++17 std::dis/conjunction, but usable in C++11 and resolves
    // to either true_type or false_type which allows for a more efficient
    // implementation that avoids recursive class template instantiation.
    template <typename... _Bn>
    struct __or_
        : decltype(__detail::__or_fn<_Bn...>(0))
    {
    };

    template <typename... _Bn>
    struct __and_
        : decltype(__detail::__and_fn<_Bn...>(0))
    {
    };

    template <typename _Pp>
    struct __not_
        : __bool_constant<!bool(_Pp::value)>
    {
    };
    /// @endcond

#ifdef __cpp_lib_logical_traits // C++ >= 17

    /// @cond undocumented
    template <typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

    namespace __detail
    {
        template <typename /* = void */, typename _B1, typename... _Bn>
        struct __disjunction_impl
        {
            using type = _B1;
        };

        template <typename _B1, typename _B2, typename... _Bn>
        struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
        {
            using type = typename __disjunction_impl<void, _B2, _Bn...>::type;
        };

        template <typename /* = void */, typename _B1, typename... _Bn>
        struct __conjunction_impl
        {
            using type = _B1;
        };

        template <typename _B1, typename _B2, typename... _Bn>
        struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
        {
            using type = typename __conjunction_impl<void, _B2, _Bn...>::type;
        };
    } // namespace __detail
    /// @endcond

    template <typename... _Bn>
    struct conjunction
        : __detail::__conjunction_impl<void, _Bn...>::type
    {
    };

    template <>
    struct conjunction<>
        : true_type
    {
    };

    template <typename... _Bn>
    struct disjunction
        : __detail::__disjunction_impl<void, _Bn...>::type
    {
    };

    template <>
    struct disjunction<>
        : false_type
    {
    };

    template <typename _Pp>
    struct negation
        : __not_<_Pp>::type
    {
    };

    /** @ingroup variable_templates
     * @{
     */
    template <typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

    template <typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

    template <typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;
    /// @}

#endif // __cpp_lib_logical_traits
       // 275
    //   174
    template <class _Ty>
    struct remove_pointer
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *const>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *volatile>
    {
        using type = _Ty;
    };

    template <class _Ty>
    struct remove_pointer<_Ty *const volatile>
    {
        using type = _Ty;
    };

    template <class _Ty>
    using remove_pointer_t = typename remove_pointer<_Ty>::type;

    template <class _Ty, class = void>
    struct _Add_pointer
    { // add pointer (pointer type cannot be formed)
        using type = _Ty;
    };

    template <class _Ty>
    struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty> *>>
    { // (pointer type can be formed)
        using type = remove_reference_t<_Ty> *;
    };

    template <class _Ty>
    struct add_pointer
    {
        using type = typename _Add_pointer<_Ty>::type;
    };

    template <class _Ty>
    using add_pointer_t = typename _Add_pointer<_Ty>::type;

    template <class>
    struct is_array
    {
        static constexpr bool value = false; // determine whether type argument is an array
    };
    template <class _Ty, size_t _Nx>
    struct is_array<_Ty[_Nx]>
    {
        static constexpr bool value = true;
    };
    template <class _Ty>
    struct is_array<_Ty[]>
    {
        static constexpr bool value = true;
    };
    // 232
    // 252
    template <class>
    struct is_lvalue_reference
    {
        static constexpr bool value = false; // determine whether type argument is an lvalue reference
    };
    template <class _Ty>
    struct is_lvalue_reference<_Ty &>
    {
        static constexpr bool value = true;
    };
    // 261
    // 270
    template <class>
    struct is_reference
    {
        static constexpr bool value = false; // determine whether type argument is a reference
    };
    template <class _Ty>
    struct is_reference<_Ty &>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_reference<_Ty &&>
    {
        static constexpr bool value = true;
    };
#if _HAS_CXX14
    template <class>
    _INLINE_VAR constexpr bool is_pointer_v = false; // determin_INLINE_VARise whether _Ty is a pointer

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *const> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *volatile> = true;

    template <class _Ty>
    _INLINE_VAR constexpr bool is_pointer_v<_Ty *const volatile> = true;
#endif
    template <class>
    struct is_pointer
    {
        static constexpr bool value = false; // determine whether _Ty is a pointer
    };
    template <class _Ty>
    struct is_pointer<_Ty *>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *const>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *volatile>
    {
        static constexpr bool value = true;
    };

    template <class _Ty>
    struct is_pointer<_Ty *const volatile>
    {
        static constexpr bool value = true;
    };
    // 300
    // 287
    /// @cond undocumented
    template <typename>
    struct __is_array_unknown_bounds;

    // Helper functions that return false_type for incomplete classes,
    // incomplete unions and arrays of known bound from those.

    template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    {
        return {};
    }
    // __remove_cv_t (std::remove_cv_t for C++11).
    template <typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;
    /// @endcond
    // 313
    // 572 故意放在前面，因为要被is_function使用
    template <class>
    struct is_const
    {
        static constexpr bool value = false; // determine whether type argument is const qualified
    };
    template <class _Ty>
    struct is_const<const _Ty>
    {
        static constexpr bool value = true;
    };
    // 581
    // 590 故意放在前面，因为要被is_convertible使用
    template <class _Ty>
    struct is_function : bool_constant<!is_const<const _Ty>::value && !is_reference<_Ty>::value>
    {
    };

    template <typename _TypeIdentity,
              typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
        is_reference<_NestedType>,
        is_function<_NestedType>,
        is_void<_NestedType>,
        __is_array_unknown_bounds<_NestedType>>::type
    __is_complete_or_unbounded(_TypeIdentity)
    {
        return {};
    }
    // 597
    // 321

    template <class _Ty>
    struct is_enum : bool_constant<__is_enum(_Ty)>
    {
    }; // determine whether _Ty is an enumerated type
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_enum_v = __is_enum(_Ty);
#endif
    // 361
    // 336
    /// @cond undocumented
    template <typename>
    struct __is_integral_helper
        : public false_type
    {
    };

    template <>
    struct __is_integral_helper<bool>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<char>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<signed char>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<unsigned char>
        : public true_type
    {
    };

    // We want is_integral<wchar_t> to be true (and make_signed/unsigned to work)
    // even when libc doesn't provide working <wchar.h> and related functions,
    // so don't check _GLIBCXX_USE_WCHAR_T here.
    template <>
    struct __is_integral_helper<wchar_t>
        : public true_type
    {
    };

#ifdef _GLIBCXX_USE_CHAR8_T
    template <>
    struct __is_integral_helper<char8_t>
        : public true_type
    {
    };
#endif

    template <>
    struct __is_integral_helper<char16_t>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<char32_t>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<short>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<unsigned short>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<int>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<unsigned int>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<long>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<unsigned long>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<long long>
        : public true_type
    {
    };

    template <>
    struct __is_integral_helper<unsigned long long>
        : public true_type
    {
    };

    // Conditionalizing on __STRICT_ANSI__ here will break any port that
    // uses one of these types for size_t.
#if defined(__GLIBCXX_TYPE_INT_N_0)
    __extension__ template <>
    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_0>
        : public true_type
    {
    };

    __extension__ template <>
    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_0>
        : public true_type
    {
    };
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
    __extension__ template <>
    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_1>
        : public true_type
    {
    };

    __extension__ template <>
    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_1>
        : public true_type
    {
    };
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
    __extension__ template <>
    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_2>
        : public true_type
    {
    };

    __extension__ template <>
    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_2>
        : public true_type
    {
    };
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
    __extension__ template <>
    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_3>
        : public true_type
    {
    };

    __extension__ template <>
    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_3>
        : public true_type
    {
    };
#endif
    /// @endcond

    /// is_integral
    template <typename _Tp>
    struct is_integral
        : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    {
    };

    /// @cond undocumented
    template <typename>
    struct __is_floating_point_helper
        : public false_type
    {
    };

    template <>
    struct __is_floating_point_helper<float>
        : public true_type
    {
    };

    template <>
    struct __is_floating_point_helper<double>
        : public true_type
    {
    };

    template <>
    struct __is_floating_point_helper<long double>
        : public true_type
    {
    };

#ifdef __STDCPP_FLOAT16_T__
    template <>
    struct __is_floating_point_helper<_Float16>
        : public true_type
    {
    };
#endif

#ifdef __STDCPP_FLOAT32_T__
    template <>
    struct __is_floating_point_helper<_Float32>
        : public true_type
    {
    };
#endif

#ifdef __STDCPP_FLOAT64_T__
    template <>
    struct __is_floating_point_helper<_Float64>
        : public true_type
    {
    };
#endif

#ifdef __STDCPP_FLOAT128_T__
    template <>
    struct __is_floating_point_helper<_Float128>
        : public true_type
    {
    };
#endif

#ifdef __STDCPP_BFLOAT16_T__
    template <>
    struct __is_floating_point_helper<__gnu_cxx::__bfloat16_t>
        : public true_type
    {
    };
#endif

#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
    template <>
    struct __is_floating_point_helper<__float128>
        : public true_type
    {
    };
#endif
    /// @endcond

    /// is_floating_point
    template <typename _Tp>
    struct is_floating_point
        : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    {
    };
    // 524
    // 576
    /// is_member_object_pointer
#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_object_pointer)
    template <typename _Tp>
    struct is_member_object_pointer
        : public __bool_constant<__is_member_object_pointer(_Tp)>
    {
    };
#else
    template <typename>
    struct __is_member_object_pointer_helper
        : public false_type
    {
    };

    template <typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
        : public __not_<is_function<_Tp>>::type
    {
    };

    template <typename _Tp>
    struct is_member_object_pointer
        : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    {
    };
#endif

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_function_pointer)
    /// is_member_function_pointer
    template <typename _Tp>
    struct is_member_function_pointer
        : public __bool_constant<__is_member_function_pointer(_Tp)>
    {
    };
#else
    template <typename>
    struct __is_member_function_pointer_helper
        : public false_type
    {
    };

    template <typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
        : public is_function<_Tp>::type
    {
    };

    /// is_member_function_pointer
    template <typename _Tp>
    struct is_member_function_pointer
        : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    {
    };
#endif
    // 620
    //    650
    template <class _Ty>
    struct is_empty : bool_constant<__is_empty(_Ty)>
    {
    }; // determine whether _Ty is an empty class
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_empty_v = __is_empty(_Ty);
#endif
// 656
// 658
#ifdef __cpp_lib_is_null_pointer // C++ >= 11
    /// is_null_pointer (LWG 2247).
    template <typename _Tp>
    struct is_null_pointer
        : public false_type
    {
    };

    template <>
    struct is_null_pointer<std::nullptr_t>
        : public true_type
    {
    };

    template <>
    struct is_null_pointer<const std::nullptr_t>
        : public true_type
    {
    };

    template <>
    struct is_null_pointer<volatile std::nullptr_t>
        : public true_type
    {
    };

    template <>
    struct is_null_pointer<const volatile std::nullptr_t>
        : public true_type
    {
    };

    /// __is_nullptr_t (deprecated extension).
    /// @deprecated Non-standard. Use `is_null_pointer` instead.
    template <typename _Tp>
    struct __is_nullptr_t
        : public is_null_pointer<_Tp>
    {
    } _GLIBCXX_DEPRECATED_SUGGEST("std::is_null_pointer");
#endif // __cpp_lib_is_null_pointer
       // 688
    //  668
    template <class _Ty>
    struct is_final : bool_constant<__is_final(_Ty)>
    {
    }; // determine whether _Ty is a final class
#if _HAS_CXX14
    template <class _Ty>
    _INLINE_VAR constexpr bool is_final_v = __is_final(_Ty);
#endif
    // 674
    // 713
    /// is_arithmetic
    template <typename _Tp>
    struct is_arithmetic
        : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    {
    };

    /// is_fundamental
    template <typename _Tp>
    struct is_fundamental
        : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
                       is_null_pointer<_Tp>>::type
    {
    };

    /// is_object
#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_object)
    template <typename _Tp>
    struct is_object
        : public __bool_constant<__is_object(_Tp)>
    {
    };
#else
    template <typename _Tp>
    struct is_object
        : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                              is_void<_Tp>>>::type
    {
    };
#endif

    template <typename>
    struct is_member_pointer;

    /// is_scalar
    template <typename _Tp>
    struct is_scalar
        : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                       is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    {
    };
// 755
/// is_member_pointer
#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_pointer)
    template <typename _Tp>
    struct is_member_pointer
        : public __bool_constant<__is_member_pointer(_Tp)>
    {
    };
#else
    /// @cond undocumented
    template <typename _Tp>
    struct __is_member_pointer_helper
        : public false_type
    {
    };

    template <typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
        : public true_type
    {
    };
    /// @endcond

    template <typename _Tp>
    struct is_member_pointer
        : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    {
    };
#endif
//  765
//  VC not well implemented, switch to boost implementation
#include "__type_traits/is_default_constructible.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_default_constructible
    template <class _Ty>
    _INLINE_VAR constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
#endif
    // __void_t (std::void_t for C++11)
    template <typename...>
    using __void_t = void;
    /// @endcond

    // 842
    // 863
    /// is_trivially_copyable
    template <typename _Tp>
    struct is_trivially_copyable
        : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
    };
    // 872
    //  883
    template <class _Ty>
    struct _Is_nonbool_integral_t : bool_constant<is_integral<_Ty>::value && !is_same<remove_cv_t<_Ty>, bool>::value>
    {
    };
    template <bool>
    struct _Select
    { // Select between aliases that extract either their first or second parameter
        template <class _Ty1, class>
        using _Apply = _Ty1;
    };

    template <>
    struct _Select<false>
    {
        template <class, class _Ty2>
        using _Apply = _Ty2;
    };
    // 898
    // 937
    /// @cond undocumented
    template <typename _Tp,
              bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
        : public false_type
    {
    };

    template <typename _Tp>
    struct __is_signed_helper<_Tp, true>
        : public __bool_constant<_Tp(-1) < _Tp(0)>
    {
    };
    /// @endcond

    /// is_signed
    template <typename _Tp>
    struct is_signed
        : public __is_signed_helper<_Tp>::type
    {
    };

    /// is_unsigned
    template <typename _Tp>
    struct is_unsigned
        : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    {
    };

    /// @cond undocumented
    template <typename _Tp, typename _Up = _Tp &&>
    _Up
    __declval(int);

    template <typename _Tp>
    _Tp
    __declval(long);
    /// @endcond

    template <typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

//  VC not well implemented, switch to LLVM, which relies on is_function
#include "__type_traits/is_convertible.h"
//   VC not well implemented, switch to boost implementation based on boost is_default_constructible
#include "__type_traits/is_constructible.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_constructible
    template <class _Ty, class... _Args>
    _INLINE_VAR constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
#endif
    //  VC not well implemented, switch to EbolaChan's personal implementation based on boost is_constructible
    template <class _Ty>
    struct is_move_constructible : is_constructible<_Ty, _Ty>
    {
        // determine whether _Ty can be direct-initialized from an rvalue _Ty
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on EbolaChan's is_constructible_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_move_constructible_v = is_constructible_v<_Ty, _Ty>;
#endif
// VC not well implemented, switch to boost implementation
#include "__type_traits/is_assignable.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_assignable
    template <class _To, class _From>
    _INLINE_VAR constexpr bool is_assignable_v = is_assignable<_To, _From>::value;
#endif
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_assignable
    template <class _Ty>
    struct is_move_assignable : is_assignable<add_lvalue_reference_t<_Ty>, _Ty>
    {
        // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on EbolaChan's is_assignable_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_move_assignable_v = is_assignable_v<add_lvalue_reference_t<_Ty>, _Ty>;
#endif
// VC not well implemented, switch to LLVM implementation
#include "__type_traits/is_nothrow_constructible.h"
    //   VC not well implemented, switch to EbolaChan's personal implementation based on LLVM is_nothrow_constructible
    template <class _Ty>
    struct is_nothrow_default_constructible : is_nothrow_constructible<_Ty>
    {
        // determine whether value-initialization of _Ty is both valid and not potentially-throwing
    };
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on LLVM is_nothrow_constructible_v
    template <class _Ty>
    _INLINE_VAR constexpr bool is_nothrow_default_constructible_v = is_nothrow_constructible_v<_Ty>;
#endif
// VC not well implemented, switch to LLVM implementation
#include "__type_traits/is_nothrow_move_constructible.h"

    // Can't be implemented without compiler builtins. Fallback to is_assginable as an approximate.
    template <class _To, class _From>
    struct is_nothrow_assignable : is_assignable<_To, _From>
    {
        // determine whether assignment of _From to _To is both valid and not potentially-throwing
    };
#if _HAS_CXX14
    // Can't be implemented without compiler builtins. Fallback to is_assginable_v as an approximate.
    template <class _To, class _From>
    _INLINE_VAR constexpr bool is_nothrow_assignable_v = is_assignable_v<_To, _From>;
#endif
// VC not well implemented, switch to boost implementation
#include "__type_traits/is_nothrow_move_assignable.hpp"
#if _HAS_CXX14
    // VC not well implemented, switch to EbolaChan's personal implementation based on boost is_nothrow_move_assignable
    template <class _Ty>
    _INLINE_VAR constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;
#endif

    template <typename>
    struct remove_all_extents;

    /// @cond undocumented
    template <typename _Tp>
    struct __is_array_known_bounds
        : public false_type
    {
    };

    template <typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
        : public true_type
    {
    };

    template <typename _Tp>
    struct __is_array_unknown_bounds
        : public false_type
    {
    };

    template <typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
        : public true_type
    {
    };

    // Destructible and constructible type properties.

    // In N3290 is_destructible does not say anything about function
    // types and abstract types, see LWG 2049. This implementation
    // describes function types as non-destructible and all complete
    // object types as destructible, iff the explicit destructor
    // call expression is wellformed.
    struct __do_is_destructible_impl
    {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())>
        static true_type __test(int);

        template <typename>
        static false_type __test(...);
    };

    template <typename _Tp>
    struct __is_destructible_impl
        : public __do_is_destructible_impl
    {
        using type = decltype(__test<_Tp>(0));
    };

    template <typename _Tp,
              bool = __or_<is_void<_Tp>,
                           __is_array_unknown_bounds<_Tp>,
                           is_function<_Tp>>::value,
              bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

    template <typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
        : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type
    {
    };

    template <typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
        : public false_type
    {
    };

    template <typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
        : public true_type
    {
    };
    /// @endcond
    // 1043
    //  1090
    template <size_t>
    struct _Make_unsigned2; // Choose make_unsigned strategy by type size

    template <>
    struct _Make_unsigned2<1>
    {
        template <class>
        using _Apply = unsigned char;
    };

    template <>
    struct _Make_unsigned2<2>
    {
        template <class>
        using _Apply = unsigned short;
    };

    template <>
    struct _Make_unsigned2<4>
    {
        template <class _Ty>
        using _Apply = // assumes LLP64
            typename _Select<is_same<_Ty, long>::value || is_same<_Ty, unsigned long>::value>::template _Apply<unsigned long,
                                                                                                               unsigned int>;
    };

    template <>
    struct _Make_unsigned2<8>
    {
        template <class>
        using _Apply = unsigned long long;
    };

    template <class _Ty>
    using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
        typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

    template <class _Ty>
    struct make_unsigned
    { // unsigned partner to _Ty
        static_assert(_Is_nonbool_integral_t<_Ty>::value || is_enum<_Ty>::value,
                      "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
                      "integral type or enumeration but not a bool type.");

        using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
    };
#endif
    template <class _Ty>
    using make_unsigned_t = typename make_unsigned<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR
    template <class _Rep>
    constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
    { // makes _Val unsigned
        return static_cast<make_unsigned_t<_Rep>>(_Val);
    }
    // 1140
    // 1052
    /// @cond undocumented

    // is_nothrow_destructible requires that is_destructible is
    // satisfied as well.  We realize that by mimicing the
    // implementation of is_destructible but refer to noexcept(expr)
    // instead of decltype(expr).
    struct __do_is_nt_destructible_impl
    {
        template <typename _Tp>
        static __bool_constant<noexcept(declval<_Tp &>().~_Tp())>
        __test(int);

        template <typename>
        static false_type __test(...);
    };

    template <typename _Tp>
    struct __is_nt_destructible_impl
        : public __do_is_nt_destructible_impl
    {
        using type = decltype(__test<_Tp>(0));
    };

    template <typename _Tp,
              bool = __or_<is_void<_Tp>,
                           __is_array_unknown_bounds<_Tp>,
                           is_function<_Tp>>::value,
              bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

    template <typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
        : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type
    {
    };

    template <typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
        : public false_type
    {
    };

    template <typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
        : public true_type
    {
    };
    /// @endcond

    /// is_nothrow_destructible
    template <typename _Tp>
    struct is_nothrow_destructible
        : public __is_nt_destructible_safe<_Tp>::type
    {
    };

    /// @cond undocumented
    template <typename _Tp, typename... _Args>
    using __is_constructible_impl = __bool_constant<is_constructible<_Tp, _Args...>::value>;
    /// @endcond
    // 1112
    //  1130  /// @cond undocumented
    template <typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp &>>
    {
        using type = _Tp &;
    };

    template <typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;
    /// @endcond

    /// is_copy_constructible
    template <typename _Tp>
    struct is_copy_constructible
        : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                      "template argument must be a complete class or an unbounded array");
    };

    /// @cond undocumented
    template <typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp &&>>
    {
        using type = _Tp &&;
    };

    template <typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;
    /// @endcond
    // 1165
    // 1402
    /// is_trivially_destructible
    template <typename _Tp>
    struct is_trivially_destructible
        : public __and_<__is_destructible_safe<_Tp>,
                        __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
    };
    // 1412
    // 1276
    template <class _Ty, unsigned int _Ix = 0>
    struct extent
    {
        static constexpr size_t value = 0; // determine extent of dimension _Ix of array _Ty
    };
    template <class _Ty, size_t _Nx>
    struct extent<_Ty[_Nx], 0>
    {
        static constexpr size_t value = _Nx;
    };
    template <class _Ty, unsigned int _Ix, size_t _Nx>
    struct extent<_Ty[_Nx], _Ix> : extent<_Ty, _Ix - 1>
    {
    };

    template <class _Ty, unsigned int _Ix>
    struct extent<_Ty[], _Ix> : extent<_Ty, _Ix - 1>
    {
    };

    template <class _Base, class _Derived>
    struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)>
    {
        // determine whether _Base is a base of or the same as _Derived
    };
#if _HAS_CXX14
    template <class _Base, class _Derived>
    _INLINE_VAR constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
#endif
    template <class _Ty>
    struct decay
    { // determines decayed version of _Ty
        using _Ty1 = remove_reference_t<_Ty>;
        using _Ty2 = typename _Select<is_function<_Ty1>::value>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
        using type = typename _Select<is_array<_Ty1>::value>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
    };
#endif
    template <class _Ty>
    using decay_t = typename decay<_Ty>::type;
#ifdef ARDUINO_ARCH_AVR

    template <class _Ty>
    _Ty _Returns_exactly() noexcept; // not defined

#if _HAS_CXX20
    _EXPORT_STD template <class, class, template <class> class, template <class> class>
    struct basic_common_reference
    {
    };

    template <class _From>
    struct _Copy_cv_impl
    {
        template <class _To>
        using _Apply = _To;
    };
    template <class _From>
    struct _Copy_cv_impl<const _From>
    {
        template <class _To>
        using _Apply = const _To;
    };
    template <class _From>
    struct _Copy_cv_impl<volatile _From>
    {
        template <class _To>
        using _Apply = volatile _To;
    };
    template <class _From>
    struct _Copy_cv_impl<const volatile _From>
    {
        template <class _To>
        using _Apply = const volatile _To;
    };
    template <class _From, class _To>
    using _Copy_cv = // N4950 [meta.trans.other]/2.3
        _Copy_cv_impl<_From>::template _Apply<_To>;

    template <class _Ty1>
    struct _Add_qualifiers
    { // _Add_qualifiers<A>::template _Apply is XREF(A) from N4950 [meta.trans.other]/2.2
        template <class _Ty2>
        using _Apply = _Copy_cv<_Ty1, _Ty2>;
    };
    template <class _Ty1>
    struct _Add_qualifiers<_Ty1 &>
    {
        template <class _Ty2>
        using _Apply = add_lvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
    };
    template <class _Ty1>
    struct _Add_qualifiers<_Ty1 &&>
    {
        template <class _Ty2>
        using _Apply = add_rvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
    };

#if !defined(__EDG__) && !defined(__clang__) // TRANSITION, DevCom-10095944
    template <class _Ty1, class _Ty2>
    using _Cond_res_if_right = // N4950 [meta.trans.other]/2.4
        decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());

    template <class _Ty>
    using _Is_scalar_or_array = disjunction<is_scalar<_Ty>, is_array<_Ty>>;

    template <class _Ty1, class _Ty2, class = void>
    struct _Cond_res_workaround
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Cond_res_workaround<_Ty1, _Ty2, void_t<_Cond_res_if_right<_Ty1, _Ty2>>>
    {
        using _Uty = remove_cvref_t<_Ty1>;
        using type = conditional_t<conjunction_v<is_same<_Uty, remove_cvref_t<_Ty2>>, _Is_scalar_or_array<_Uty>,
                                                 disjunction<conjunction<is_lvalue_reference<_Ty1>, is_rvalue_reference<_Ty2>>,
                                                             conjunction<is_rvalue_reference<_Ty1>, is_lvalue_reference<_Ty2>>>>,
                                   decay_t<_Copy_cv<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>>, _Cond_res_if_right<_Ty1, _Ty2>>;
    };

    template <class _Ty1, class _Ty2>
    using _Cond_res = _Cond_res_workaround<_Ty1, _Ty2>::type;
#else  // ^^^ workaround / no workaround vvv
    template <class _Ty1, class _Ty2>
    using _Cond_res = // N4950 [meta.trans.other]/2.4
        decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());
#endif // ^^^ no workaround ^^^

    _EXPORT_STD template <class...>
    struct common_reference;

    _EXPORT_STD template <class... _Types>
    using common_reference_t = common_reference<_Types...>::type;

    // N4950 [meta.trans.other]/5.1: "If sizeof...(T) is zero ..."
    template <>
    struct common_reference<>
    {
    };

    // N4950 [meta.trans.other]/5.2: "...if sizeof...(T) is one ..."
    template <class _Ty>
    struct common_reference<_Ty>
    {
        using type = _Ty;
    };

    // N4950 [meta.trans.other]/5.3: "...if sizeof...(T) is two..."

    // N4950 [meta.trans.other]/5.3.4: "if common_type_t<T1, T2> is well-formed..."
    // N4950 [meta.trans.other]/5.3.5: "Otherwise, there shall be no member type."
    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2C : common_type<_Ty1, _Ty2>
    {
    };

    // N4950 [meta.trans.other]/5.3.3: "if COND_RES(T1, T2) is well-formed..."
    template <class _Ty1, class _Ty2>
    struct _Common_reference2C<_Ty1, _Ty2, void_t<_Cond_res<_Ty1, _Ty2>>>
    {
        using type = _Cond_res<_Ty1, _Ty2>;
    };

    // N4950 [meta.trans.other]/5.3.2: "if basic_common_reference<[...]>::type is well-formed..."
    template <class _Ty1, class _Ty2>
    using _Basic_specialization = basic_common_reference<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>,
                                                         _Add_qualifiers<_Ty1>::template _Apply, _Add_qualifiers<_Ty2>::template _Apply>::type;

    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2B : _Common_reference2C<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2B<_Ty1, _Ty2, void_t<_Basic_specialization<_Ty1, _Ty2>>>
    {
        using type = _Basic_specialization<_Ty1, _Ty2>;
    };

    // N4950 [meta.trans.other]/5.3.1: "Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is well-formed, and
    // is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> && is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is
    // true, then the member typedef type denotes R."
    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2A : _Common_reference2B<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2, class _Result = _Cond_res<_Copy_cv<_Ty1, _Ty2> &, _Copy_cv<_Ty2, _Ty1> &>,
              enable_if_t<is_lvalue_reference_v<_Result>, int> = 0>
    using _LL_common_ref = _Result;

    template <class _Ty1, class _Ty2, class = void>
    struct _Common_reference2AX
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &, _Ty2 &, void_t<_LL_common_ref<_Ty1, _Ty2>>>
    {
        using type = _LL_common_ref<_Ty1, _Ty2>; // "both lvalues" case from N4950 [meta.trans.other]/2.5
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &&, _Ty2 &, enable_if_t<is_convertible_v<_Ty1 &&, _LL_common_ref<const _Ty1, _Ty2>>>>
    {
        using type = _LL_common_ref<const _Ty1, _Ty2>; // "rvalue and lvalue" case from N4950 [meta.trans.other]/2.7
    };

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &, _Ty2 &&, enable_if_t<is_convertible_v<_Ty2 &&, _LL_common_ref<const _Ty2, _Ty1>>>>
    {
        using type = _LL_common_ref<const _Ty2, _Ty1>; // "lvalue and rvalue" case from N4950 [meta.trans.other]/2.8
    };

    template <class _Ty1, class _Ty2>
    using _RR_common_ref = remove_reference_t<_LL_common_ref<_Ty1, _Ty2>> &&;

    template <class _Ty1, class _Ty2>
    struct _Common_reference2AX<_Ty1 &&, _Ty2 &&,
                                enable_if_t<is_convertible_v<_Ty1 &&, _RR_common_ref<_Ty1, _Ty2>> && is_convertible_v<_Ty2 &&, _RR_common_ref<_Ty1, _Ty2>>>>
    {
        using type = _RR_common_ref<_Ty1, _Ty2>; // "both rvalues" case from N4950 [meta.trans.other]/2.6
    };

    template <class _Ty1, class _Ty2>
    using _Common_ref_2AX_t = _Common_reference2AX<_Ty1, _Ty2>::type;

    template <class _Ty1, class _Ty2>
    struct _Common_reference2A<_Ty1, _Ty2,
                               enable_if_t<is_convertible_v<add_pointer_t<_Ty1>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>> && is_convertible_v<add_pointer_t<_Ty2>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>>>>
    {
        using type = _Common_ref_2AX_t<_Ty1, _Ty2>;
    };

    template <class _Ty1, class _Ty2>
    struct common_reference<_Ty1, _Ty2> : _Common_reference2A<_Ty1, _Ty2>
    {
    };

    // N4950 [meta.trans.other]/5.4: "if sizeof...(T) is greater than two..."
    template <class _Void, class _Ty1, class _Ty2, class... _Types>
    struct _Fold_common_reference
    {
    };
    template <class _Ty1, class _Ty2, class... _Types>
    struct _Fold_common_reference<void_t<common_reference_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Types...>
        : common_reference<common_reference_t<_Ty1, _Ty2>, _Types...>
    {
    };

    template <class _Ty1, class _Ty2, class _Ty3, class... _Rest>
    struct common_reference<_Ty1, _Ty2, _Ty3, _Rest...> : _Fold_common_reference<void, _Ty1, _Ty2, _Ty3, _Rest...>
    {
    };

    _EXPORT_STD template <class _Ty>
    struct type_identity
    {
        using type = _Ty;
    };
    _EXPORT_STD template <class _Ty>
    using type_identity_t = type_identity<_Ty>::type;
#endif // _HAS_CXX20
#if _HAS_CXX14
    template <class _Type, template <class...> class _Template>
    _INLINE_VAR constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
    template <template <class...> class _Template, class... _Types>
    _INLINE_VAR constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;
#endif
    template <class _Type, template <class...> class _Template>
    struct _Is_specialization
    {
        static constexpr bool value = false; // true if and only if _Type is a specialization of _Template
    };
    template <template <class...> class _Template, class... _Types>
    struct _Is_specialization<_Template<_Types...>, _Template>
    {
        static constexpr bool value = true;
    };
#endif
// 2693
// 1423
#ifdef ARDUINO_ARCH_AVR
    // type property queries.

    /// alignment_of
    template <typename _Tp>
    struct alignment_of
        : public integral_constant<std::size_t, alignof(_Tp)>
    {
    };
    // 1434
    // 1599
    // Const-volatile modifications.

    /// remove_const
    template <typename _Tp>
    struct remove_const
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct remove_const<_Tp const>
    {
        using type = _Tp;
    };

    /// remove_volatile
    template <typename _Tp>
    struct remove_volatile
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct remove_volatile<_Tp volatile>
    {
        using type = _Tp;
    };

    /// remove_cv
#if _GLIBCXX_USE_BUILTIN_TRAIT(__remove_cv)
    template <typename _Tp>
    struct remove_cv
    {
        using type = __remove_cv(_Tp);
    };
#else
    template <typename _Tp>
    struct remove_cv
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct remove_cv<const _Tp>
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct remove_cv<volatile _Tp>
    {
        using type = _Tp;
    };

    template <typename _Tp>
    struct remove_cv<const volatile _Tp>
    {
        using type = _Tp;
    };
#endif

    /// add_const
    template <typename _Tp>
    struct add_const
    {
        using type = _Tp const;
    };

    /// add_volatile
    template <typename _Tp>
    struct add_volatile
    {
        using type = _Tp volatile;
    };

    /// add_cv
    template <typename _Tp>
    struct add_cv
    {
        using type = _Tp const volatile;
    };

#ifdef __cpp_lib_transformation_trait_aliases // C++ >= 14
    /// Alias template for remove_const
    template <typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;

    /// Alias template for remove_volatile
    template <typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;

    /// Alias template for remove_cv
    template <typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;

    /// Alias template for add_const
    template <typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;

    /// Alias template for add_volatile
    template <typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;

    /// Alias template for add_cv
    template <typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;
#endif
    // 1683
#endif
    /// Alias template for enable_if
    template <bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    // 2295
    //  __decay_t (std::decay_t for C++11).
    template <typename _Tp>
    using __decay_t = typename decay<_Tp>::type;
// 2299
// 2303
/// @cond undocumented
#ifdef ARDUINO_ARCH_SAM

#endif
#ifdef ARDUINO_ARCH_AVR
    // Helper for SFINAE constraints
    template <typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;

    //   __remove_cvref_t (std::remove_cvref_t for C++11).
    template <typename _Tp>
    using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    /// @endcond
    // 2315
    // 2326
    /// common_type
    template <typename... _Tp>
    struct common_type;

    //   Sfinae-friendly common_type implementation:

    /// @cond undocumented

    // For several sfinae-friendly trait implementations we transport both the
    // result information (as the member type) and the failure information (no
    // member type). This is very similar to std::enable_if, but we cannot use
    // that, because we need to derive from them as an implementation detail.

    template <typename _Tp>
    struct __success_type
    {
        using type = _Tp;
    };

    struct __failure_type
    {
    };

    struct __do_common_type_impl
    {
        template <typename _Tp, typename _Up>
        using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());

        // if decay_t<decltype(false ? declval<D1>() : declval<D2>())>
        // denotes a valid type, let C denote that type.
        template <typename _Tp, typename _Up>
        static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
        _S_test(int);

#if __cplusplus > 201703L
        // Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type,
        // let C denote the type decay_t<COND-RES(CREF(D1), CREF(D2))>.
        template <typename _Tp, typename _Up>
        static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>>
        _S_test_2(int);
#endif

        template <typename, typename>
        static __failure_type
        _S_test_2(...);

        template <typename _Tp, typename _Up>
        static decltype(_S_test_2<_Tp, _Up>(0))
        _S_test(...);
    };

    // If sizeof...(T) is zero, there shall be no member type.
    template <>
    struct common_type<>
    {
    };

    // If sizeof...(T) is one, the same type, if any, as common_type_t<T0, T0>.
    template <typename _Tp0>
    struct common_type<_Tp0>
        : public common_type<_Tp0, _Tp0>
    {
    };

    // If sizeof...(T) is two, ...
    template <typename _Tp1, typename _Tp2,
              typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {
        // If is_same_v<T1, D1> is false or is_same_v<T2, D2> is false,
        // let C denote the same type, if any, as common_type_t<D1, D2>.
        using type = common_type<_Dp1, _Dp2>;
    };

    template <typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
        : private __do_common_type_impl
    {
        // Otherwise, if decay_t<decltype(false ? declval<D1>() : declval<D2>())>
        // denotes a valid type, let C denote that type.
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };

    // If sizeof...(T) is two, ...
    template <typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
        : public __common_type_impl<_Tp1, _Tp2>::type
    {
    };

    template <typename...>
    struct __common_type_pack
    {
    };

    template <typename, typename, typename = void>
    struct __common_type_fold;

    // If sizeof...(T) is greater than two, ...
    template <typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
        : public __common_type_fold<common_type<_Tp1, _Tp2>,
                                    __common_type_pack<_Rp...>>
    {
    };

    // Let C denote the same type, if any, as common_type_t<T1, T2>.
    // If there is such a type C, type shall denote the same type, if any,
    // as common_type_t<C, R...>.
    template <typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
                              __void_t<typename _CTp::type>>
        : public common_type<typename _CTp::type, _Rp...>
    {
    };

    // Otherwise, there shall be no member type.
    template <typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    {
    };

    template <typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
        using type = __underlying_type(_Tp);
    };

    template <typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    {
    };
    /// @endcond

    /// The underlying type of an enum.
    template <typename _Tp>
    struct underlying_type
        : public __underlying_type_impl<_Tp>
    {
    };

    /// @cond undocumented
    template <typename _Tp>
    struct __declval_protector
    {
        static const bool __stop = false;
    };
    /// @endcond

    /** Utility to simplify expressions used in unevaluated operands
     *  @since C++11
     *  @ingroup utilities
     */
    template <typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
        static_assert(__declval_protector<_Tp>::__stop,
                      "declval() must not be used!");
        return __declval<_Tp>(0);
    }
#endif
#ifndef ARDUINO_ARCH_ESP32
    /// result_of
    template <typename _Signature>
    struct result_of;

    // Sfinae-friendly result_of implementation:

    /// @cond undocumented
    struct __invoke_memfun_ref
    {
    };
    struct __invoke_memfun_deref
    {
    };
    struct __invoke_memobj_ref
    {
    };
    struct __invoke_memobj_deref
    {
    };
    struct __invoke_other
    {
    };

    // Associate a tag type with a specialization of __success_type.
    template <typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    {
        using __invoke_type = _Tag;
    };
#endif
#ifdef ARDUINO_ARCH_AVR
    // [func.require] paragraph 1 bullet 1:
    struct __result_of_memfun_ref_impl
    {
        template <typename _Fp, typename _Tp1, typename... _Args>
        static __result_of_success<decltype((std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)), __invoke_memfun_ref> _S_test(int);

        template <typename...>
        static __failure_type _S_test(...);
    };

    template <typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
        : private __result_of_memfun_ref_impl
    {
        using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };

    // [func.require] paragraph 1 bullet 2:
    struct __result_of_memfun_deref_impl
    {
        template <typename _Fp, typename _Tp1, typename... _Args>
        static __result_of_success<decltype(((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)), __invoke_memfun_deref> _S_test(int);

        template <typename...>
        static __failure_type _S_test(...);
    };

    template <typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
        : private __result_of_memfun_deref_impl
    {
        using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };

    // [func.require] paragraph 1 bullet 3:
    struct __result_of_memobj_ref_impl
    {
        template <typename _Fp, typename _Tp1>
        static __result_of_success<decltype(std::declval<_Tp1>().*std::declval<_Fp>()), __invoke_memobj_ref> _S_test(int);

        template <typename, typename>
        static __failure_type _S_test(...);
    };

    template <typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
        : private __result_of_memobj_ref_impl
    {
        using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

    // [func.require] paragraph 1 bullet 4:
    struct __result_of_memobj_deref_impl
    {
        template <typename _Fp, typename _Tp1>
        static __result_of_success<decltype((*std::declval<_Tp1>()).*std::declval<_Fp>()), __invoke_memobj_deref> _S_test(int);

        template <typename, typename>
        static __failure_type _S_test(...);
    };

    template <typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
        : private __result_of_memobj_deref_impl
    {
        using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

    template <typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

    template <typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
        using _Argval = __remove_cvref_t<_Arg>;
        using _MemPtr = _Res _Class::*;
        using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
                                                    is_base_of<_Class, _Argval>>::value,
                                              __result_of_memobj_ref<_MemPtr, _Arg>,
                                              __result_of_memobj_deref<_MemPtr, _Arg>>::type;
    };

    template <typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

    template <typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
        using _Argval = typename remove_reference<_Arg>::type;
        using _MemPtr = _Res _Class::*;
        using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
                                              __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
                                              __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type;
    };

    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // 2219.  INVOKE-ing a pointer to member with a reference_wrapper
    //        as the object expression

    // Used by result_of, invoke etc. to unwrap a reference_wrapper.
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
        using type = _Tp;
    };

    template <typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
        using type = _Up &;
    };

    template <bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
        using type = __failure_type;
    };

    template <typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
        : public __result_of_memobj<__decay_t<_MemPtr>,
                                    typename __inv_unwrap<_Arg>::type>
    {
    };

    template <typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
        : public __result_of_memfun<__decay_t<_MemPtr>,
                                    typename __inv_unwrap<_Arg>::type, _Args...>
    {
    };

    // [func.require] paragraph 1 bullet 5:
    struct __result_of_other_impl
    {
        template <typename _Fn, typename... _Args>
        static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), __invoke_other> _S_test(int);

        template <typename...>
        static __failure_type _S_test(...);
    };

    template <typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
        : private __result_of_other_impl
    {
        using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };

    // __invoke_result (std::invoke_result for C++11)
    template <typename _Functor, typename... _ArgTypes>
    struct __invoke_result
        : public __result_of_impl<
              is_member_object_pointer<
                  typename remove_reference<_Functor>::type>::value,
              is_member_function_pointer<
                  typename remove_reference<_Functor>::type>::value,
              _Functor, _ArgTypes...>::type
    {
    };
    // 2667
    // 2701
    /// Alias template for common_type
    template <typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;
    // 2705
    // 2719
    /// @cond undocumented

    // Detection idiom.
    // Detect whether _Op<_Args...> is a valid type, use default _Def if not.

#if __cpp_concepts
    // Implementation of the detection idiom (negative case).
    template <typename _Def, template <typename...> class _Op, typename... _Args>
    struct __detected_or
    {
        using type = _Def;
        using __is_detected = false_type;
    };

    // Implementation of the detection idiom (positive case).
    template <typename _Def, template <typename...> class _Op, typename... _Args>
        requires requires { typename _Op<_Args...>; }
    struct __detected_or<_Def, _Op, _Args...>
    {
        using type = _Op<_Args...>;
        using __is_detected = true_type;
    };
#else
    /// Implementation of the detection idiom (negative case).
    template <typename _Default, typename _AlwaysVoid,
              template <typename...> class _Op, typename... _Args>
    struct __detector
    {
        using type = _Default;
        using __is_detected = false_type;
    };

    /// Implementation of the detection idiom (positive case).
    template <typename _Default, template <typename...> class _Op,
              typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
        using type = _Op<_Args...>;
        using __is_detected = true_type;
    };

    template <typename _Default, template <typename...> class _Op,
              typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;
#endif // __cpp_concepts

    // _Op<_Args...> if that is a valid type, otherwise _Default.
    template <typename _Default, template <typename...> class _Op,
              typename... _Args>
    using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    // 2771
    // 2785
    template <typename _Tp>
    struct __is_swappable;

    template <typename _Tp>
    struct __is_nothrow_swappable;

    template <typename>
    struct __is_tuple_like_impl : false_type
    {
    };

    // Internal type trait that allows us to sfinae-protect tuple_cat.
    template <typename _Tp>
    struct __is_tuple_like
        : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    {
    };
    /// @endcond

    template <typename _Tp>
    _GLIBCXX20_CONSTEXPR inline _Require<__not_<__is_tuple_like<_Tp>>,
                                         is_move_constructible<_Tp>,
                                         is_move_assignable<_Tp>>
    swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                                       is_nothrow_move_assignable<_Tp>>::value);

    template <typename _Tp, size_t _Nm>
    _GLIBCXX20_CONSTEXPR inline __enable_if_t<__is_swappable<_Tp>::value>
        swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);

    /// @cond undocumented
    namespace __swappable_details
    {
        using std::swap;

        struct __do_is_swappable_impl
        {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))>
            static true_type __test(int);

            template <typename>
            static false_type __test(...);
        };

        struct __do_is_nothrow_swappable_impl
        {
            template <typename _Tp>
            static __bool_constant<
                noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))>
            __test(int);

            template <typename>
            static false_type __test(...);
        };

    } // namespace __swappable_details

    template <typename _Tp>
    struct __is_swappable_impl
        : public __swappable_details::__do_is_swappable_impl
    {
        using type = decltype(__test<_Tp>(0));
    };

    template <typename _Tp>
    struct __is_nothrow_swappable_impl
        : public __swappable_details::__do_is_nothrow_swappable_impl
    {
        using type = decltype(__test<_Tp>(0));
    };

    template <typename _Tp>
    struct __is_swappable
        : public __is_swappable_impl<_Tp>::type
    {
    };

    template <typename _Tp>
    struct __is_nothrow_swappable
        : public __is_nothrow_swappable_impl<_Tp>::type
    {
    };
    /// @endcond

#ifdef __cpp_lib_is_swappable // C++ >= 17 || GNU++ >= 11

    /// Metafunctions used for detecting swappable types: p0185r1

    /// is_swappable
    template <typename _Tp>
    struct is_swappable
        : public __is_swappable_impl<_Tp>::type
    {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                      "template argument must be a complete class or an unbounded array");
    };

    /// is_nothrow_swappable
    template <typename _Tp>
    struct is_nothrow_swappable
        : public __is_nothrow_swappable_impl<_Tp>::type
    {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                      "template argument must be a complete class or an unbounded array");
    };
#endif
#if __cplusplus >= 201402L
    /// is_swappable_v
    template <typename _Tp>
    _GLIBCXX17_INLINE constexpr bool is_swappable_v =
        is_swappable<_Tp>::value;

    /// is_nothrow_swappable_v
    template <typename _Tp>
    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_v =
        is_nothrow_swappable<_Tp>::value;
#endif // __cplusplus >= 201402L

    /// @cond undocumented
    namespace __swappable_with_details
    {
        using std::swap;

        struct __do_is_swappable_with_impl
        {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
                      typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
            static true_type __test(int);

            template <typename, typename>
            static false_type __test(...);
        };

        struct __do_is_nothrow_swappable_with_impl
        {
            template <typename _Tp, typename _Up>
            static __bool_constant<
                noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) &&
                noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))>
            __test(int);

            template <typename, typename>
            static false_type __test(...);
        };

    } // namespace __swappable_with_details

    template <typename _Tp, typename _Up>
    struct __is_swappable_with_impl
        : public __swappable_with_details::__do_is_swappable_with_impl
    {
        using type = decltype(__test<_Tp, _Up>(0));
    };

    // Optimization for the homogenous lvalue case, not required:
    template <typename _Tp>
    struct __is_swappable_with_impl<_Tp &, _Tp &>
        : public __swappable_details::__do_is_swappable_impl
    {
        using type = decltype(__test<_Tp &>(0));
    };

    template <typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
        : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
        using type = decltype(__test<_Tp, _Up>(0));
    };

    // Optimization for the homogenous lvalue case, not required:
    template <typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &>
        : public __swappable_details::__do_is_nothrow_swappable_impl
    {
        using type = decltype(__test<_Tp &>(0));
    };
    /// @endcond
#ifdef ARDUINO_ARCH_AVR
    /// is_swappable_with
    template <typename _Tp, typename _Up>
    struct is_swappable_with
        : public __is_swappable_with_impl<_Tp, _Up>::type
    {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                      "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                      "second template argument must be a complete class or an unbounded array");
    };

    /// is_nothrow_swappable_with
    template <typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
        : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                      "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                      "second template argument must be a complete class or an unbounded array");
    };
#endif
#if __cplusplus >= 201402L
    /// is_swappable_with_v
    template <typename _Tp, typename _Up>
    _GLIBCXX17_INLINE constexpr bool is_swappable_with_v =
        is_swappable_with<_Tp, _Up>::value;

    /// is_nothrow_swappable_with_v
    template <typename _Tp, typename _Up>
    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_with_v =
        is_nothrow_swappable_with<_Tp, _Up>::value;
#endif // __cplusplus >= 201402L

#endif // __cpp_lib_is_swappable
#ifndef ARDUINO_ARCH_ESP32
    /// @cond undocumented

    // __is_invocable (std::is_invocable for C++11)

    // The primary template is used for invalid INVOKE expressions.
    template <typename _Result, typename _Ret,
              bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
        : false_type
    {
        using __nothrow_conv = false_type; // For is_nothrow_invocable_r
    };
#endif
#ifdef ARDUINO_ARCH_AVR
    // Used for valid INVOKE and INVOKE<void> expressions.
    template <typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                               /* is_void<_Ret> = */ true,
                               __void_t<typename _Result::type>>
        : true_type
    {
        using __nothrow_conv = true_type; // For is_nothrow_invocable_r
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
    // Used for INVOKE<R> expressions to check the implicit conversion to R.
    template <typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                               /* is_void<_Ret> = */ false,
                               __void_t<typename _Result::type>>
    {
    private:
        // The type of the INVOKE expression.
        using _Res_t = typename _Result::type;

        // Unlike declval, this doesn't add_rvalue_reference, so it respects
        // guaranteed copy elision.
        static _Res_t _S_get() noexcept;

        // Used to check if _Res_t can implicitly convert to _Tp.
        template <typename _Tp>
        static void _S_conv(__type_identity_t<_Tp>) noexcept;

        // This overload is viable if INVOKE(f, args...) can convert to _Tp.
        template <typename _Tp,
                  bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
                  typename = decltype(_S_conv<_Tp>(_S_get())),
#if __has_builtin(__reference_converts_from_temporary)
                  bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)
#else
                  bool _Dangle = false
#endif
                  >
        static __bool_constant<_Nothrow && !_Dangle>
        _S_test(int);

        template <typename _Tp, bool = false>
        static false_type
        _S_test(...);

    public:
        // For is_invocable_r
        using type = decltype(_S_test<_Ret, /* Nothrow = */ true>(1));

        // For is_nothrow_invocable_r
        using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

    template <typename _Fn, typename... _ArgTypes>
    struct __is_invocable
        : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
    };

    template <typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
            std::declval<_Args>()...));
    }

    template <typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
        return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
            std::declval<_Args>()...));
    }

    template <typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

    template <typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
        return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

    template <typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

    template <typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
        : __bool_constant<
              std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})>
    {
    };

    template <typename _Fn, typename... _Args>
    using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;

    // __is_nothrow_invocable (std::is_nothrow_invocable for C++11)
    template <typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
        : __and_<__is_invocable<_Fn, _Args...>,
                 __call_is_nothrow_<_Fn, _Args...>>::type
    {
    };
// 3128
#endif
// 3139
#ifndef ARDUINO_ARCH_ESP32
#ifdef __cpp_lib_is_invocable // C++ >= 17
    /// std::invoke_result
    template <typename _Functor, typename... _ArgTypes>
    struct invoke_result
        : public __invoke_result<_Functor, _ArgTypes...>
    {
    };

    /// std::invoke_result_t
    template <typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;

    /// std::is_invocable
    template <typename _Fn, typename... _ArgTypes>
    struct is_invocable
        : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
    };

    /// std::is_invocable_r
    template <typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
        : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
    };

    /// std::is_nothrow_invocable
    template <typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
        : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
                 __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
    };

    /// @cond undocumented
    // This checks that the INVOKE<R> expression is well-formed and that the
    // conversion to R does not throw. It does *not* check whether the INVOKE
    // expression itself can throw. That is done by __call_is_nothrow_ instead.
    template <typename _Result, typename _Ret>
    using __is_nt_invocable_impl = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;
    /// @endcond

    /// std::is_nothrow_invocable_r
    template <typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
        : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
                 __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
    };
#endif // __cpp_lib_is_invocable

#if __cpp_lib_type_trait_variable_templates // C++ >= 17
                                            /**
                                             * @defgroup variable_templates Variable templates for type traits
                                             * @ingroup metaprogramming
                                             *
                                             * Each variable `is_xxx_v<T>` is a boolean constant with the same value
                                             * as the `value` member of the corresponding type trait `is_xxx<T>`.
                                             *
                                             * @since C++17 unless noted otherwise.
                                             */

    /**
     * @{
     * @ingroup variable_templates
     */
    template <typename _Tp>
    inline constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_integral_v = is_integral<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_array)
    template <typename _Tp>
    inline constexpr bool is_array_v = __is_array(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_array_v = false;
    template <typename _Tp>
    inline constexpr bool is_array_v<_Tp[]> = true;
    template <typename _Tp, size_t _Num>
    inline constexpr bool is_array_v<_Tp[_Num]> = true;
#endif

    template <typename _Tp>
    inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_lvalue_reference_v = false;
    template <typename _Tp>
    inline constexpr bool is_lvalue_reference_v<_Tp &> = true;
    template <typename _Tp>
    inline constexpr bool is_rvalue_reference_v = false;
    template <typename _Tp>
    inline constexpr bool is_rvalue_reference_v<_Tp &&> = true;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_object_pointer)
    template <typename _Tp>
    inline constexpr bool is_member_object_pointer_v =
        __is_member_object_pointer(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_member_object_pointer_v =
        is_member_object_pointer<_Tp>::value;
#endif

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_function_pointer)
    template <typename _Tp>
    inline constexpr bool is_member_function_pointer_v =
        __is_member_function_pointer(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_member_function_pointer_v =
        is_member_function_pointer<_Tp>::value;
#endif

    template <typename _Tp>
    inline constexpr bool is_enum_v = __is_enum(_Tp);
    template <typename _Tp>
    inline constexpr bool is_union_v = __is_union(_Tp);
    template <typename _Tp>
    inline constexpr bool is_class_v = __is_class(_Tp);
    // is_function_v is defined below, after is_const_v.

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_reference)
    template <typename _Tp>
    inline constexpr bool is_reference_v = __is_reference(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_reference_v = false;
    template <typename _Tp>
    inline constexpr bool is_reference_v<_Tp &> = true;
    template <typename _Tp>
    inline constexpr bool is_reference_v<_Tp &&> = true;
#endif

    template <typename _Tp>
    inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_object)
    template <typename _Tp>
    inline constexpr bool is_object_v = __is_object(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_object_v = is_object<_Tp>::value;
#endif

    template <typename _Tp>
    inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_member_pointer)
    template <typename _Tp>
    inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
#endif

    template <typename _Tp>
    inline constexpr bool is_const_v = false;
    template <typename _Tp>
    inline constexpr bool is_const_v<const _Tp> = true;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_function)
    template <typename _Tp>
    inline constexpr bool is_function_v = __is_function(_Tp);
#else
    template <typename _Tp>
    inline constexpr bool is_function_v = !is_const_v<const _Tp>;
    template <typename _Tp>
    inline constexpr bool is_function_v<_Tp &> = false;
    template <typename _Tp>
    inline constexpr bool is_function_v<_Tp &&> = false;
#endif

    template <typename _Tp>
    inline constexpr bool is_volatile_v = false;
    template <typename _Tp>
    inline constexpr bool is_volatile_v<volatile _Tp> = true;

    template <typename _Tp>
    inline constexpr bool is_trivial_v = __is_trivial(_Tp);
    template <typename _Tp>
    inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
    template <typename _Tp>
    inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
    template <typename _Tp>
    _GLIBCXX20_DEPRECATED_SUGGEST("is_standard_layout_v && is_trivial_v")
    inline constexpr bool is_pod_v = __is_pod(_Tp);
    template <typename _Tp>
    _GLIBCXX17_DEPRECATED inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
    template <typename _Tp>
    inline constexpr bool is_empty_v = __is_empty(_Tp);
    template <typename _Tp>
    inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
    template <typename _Tp>
    inline constexpr bool is_abstract_v = __is_abstract(_Tp);
    template <typename _Tp>
    inline constexpr bool is_final_v = __is_final(_Tp);

    template <typename _Tp>
    inline constexpr bool is_signed_v = is_signed<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

    template <typename _Tp>
    inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

    template <typename _Tp, typename... _Args>
    inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);
    template <typename _Tp>
    inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);
    template <typename _Tp>
    inline constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
    template <typename _Tp>
    inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

    template <typename _Tp, typename _Up>
    inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Up);
    template <typename _Tp>
    inline constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
                                                                                     __add_lval_ref_t<const _Tp>);
    template <typename _Tp>
    inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
                                                                                     __add_rval_ref_t<_Tp>);

#if __cpp_concepts
    template <typename _Tp>
    inline constexpr bool is_trivially_destructible_v = false;

    template <typename _Tp>
        requires(!is_reference_v<_Tp>) && requires(_Tp &__t) { __t.~_Tp(); }
    inline constexpr bool is_trivially_destructible_v<_Tp> = __has_trivial_destructor(_Tp);
    template <typename _Tp>
    inline constexpr bool is_trivially_destructible_v<_Tp &> = true;
    template <typename _Tp>
    inline constexpr bool is_trivially_destructible_v<_Tp &&> = true;
    template <typename _Tp, size_t _Nm>
    inline constexpr bool is_trivially_destructible_v<_Tp[_Nm]> = is_trivially_destructible_v<_Tp>;
#else
    template <typename _Tp>
    inline constexpr bool is_trivially_destructible_v =
        is_trivially_destructible<_Tp>::value;
#endif

    template <typename _Tp>
    inline constexpr bool is_nothrow_destructible_v =
        is_nothrow_destructible<_Tp>::value;

    template <typename _Tp>
    inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);

    template <typename _Tp>
    inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

    template <typename _Tp>
    inline constexpr size_t rank_v = 0;
    template <typename _Tp, size_t _Size>
    inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
    template <typename _Tp>
    inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

    template <typename _Tp, unsigned _Idx = 0>
    inline constexpr size_t extent_v = 0;
    template <typename _Tp, size_t _Size>
    inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
    template <typename _Tp, unsigned _Idx, size_t _Size>
    inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
    template <typename _Tp>
    inline constexpr size_t extent_v<_Tp[], 0> = 0;
    template <typename _Tp, unsigned _Idx>
    inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;

#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_same)
    template <typename _Tp, typename _Up>
    inline constexpr bool is_same_v = __is_same(_Tp, _Up);
#else
    template <typename _Tp, typename _Up>
    inline constexpr bool is_same_v = false;
    template <typename _Tp>
    inline constexpr bool is_same_v<_Tp, _Tp> = true;
#endif
    template <typename _Base, typename _Derived>
    inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_convertible)
    template <typename _From, typename _To>
    inline constexpr bool is_convertible_v = __is_convertible(_From, _To);
#else
    template <typename _From, typename _To>
    inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
#endif
    template <typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
    template <typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
/// @}
#endif // __cpp_lib_type_trait_variable_templates
#endif
// 3535
#ifndef ARDUINO_ARCH_ESP32
//   3642
#ifdef __cpp_lib_bounded_array_traits // C++ >= 20
                                      /// True for a type that is an array of known bound.
                                      /// @ingroup variable_templates
                                      /// @since C++20
#if _GLIBCXX_USE_BUILTIN_TRAIT(__is_bounded_array)
    template <typename _Tp>
    struct is_bounded_array
        : public bool_constant<__is_bounded_array(_Tp)>
    {
    };
#else
    template <typename _Tp>
    struct is_bounded_array
        : public bool_constant<false>
    {
    };

    template <typename _Tp, size_t _Size>
    struct is_bounded_array<_Tp[_Size]>
        : public bool_constant<true>
    {
    };
#endif

    /// True for a type that is an array of unknown bound.
    /// @ingroup variable_templates
    /// @since C++20
    template <typename _Tp>
    struct is_unbounded_array
        : public bool_constant<false>
    {
    };

    template <typename _Tp>
    struct is_unbounded_array<_Tp[]>
        : public bool_constant<true>
    {
    };
#if __cplusplus >= 201402
    /// True for a type that is an array of known bound.
    /// @since C++20
    template <typename _Tp>
    inline constexpr bool is_bounded_array_v = is_bounded_array<_Tp>::value;

    /// True for a type that is an array of unknown bound.
    /// @since C++20
    template <typename _Tp>
    inline constexpr bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;
#endif
#endif // __cpp_lib_bounded_array_traits
// 3681
#endif
}
#pragma GCC visibility pop