#pragma once
#include "yvals_core.h"
_STD_BEGIN
#ifdef ARDUINO_ARCH_AVR
template <bool _Test, class _Ty1, class _Ty2>
struct conditional
{ // Choose _Ty1 if _Test is true, and _Ty2 otherwise
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2>
{
    using type = _Ty2;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

#ifdef __clang__
template <class _Ty1, class _Ty2>
_INLINE_VAR constexpr bool is_same_v = __is_same(_Ty1, _Ty2);

template <class _Ty1, class _Ty2>
struct is_same : bool_constant<__is_same(_Ty1, _Ty2)>
{
};
#else // ^^^ Clang / not Clang vvv

template <class, class>
struct is_same
{
    static constexpr bool value = false; // determine whether arguments are the same type
};
template <class _Ty>
struct is_same<_Ty, _Ty>
{
    static constexpr bool value = true;
};
#endif // __clang__
// 81
// 122
_EXPORT_STD template <class _Ty>
struct remove_cv
{ // remove top-level const and volatile qualifiers
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; // apply cv-qualifiers from the class template argument to _Fn<_Ty>
};

template <class _Ty>
struct remove_cv<const _Ty>
{
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty>
{
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty>
{
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

_EXPORT_STD template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct remove_reference
{
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty &>
{
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty &;
};

template <class _Ty>
struct remove_reference<_Ty &&>
{
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty &&;
};

_EXPORT_STD template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t _MSVC_KNOWN_SEMANTICS = remove_cv_t<remove_reference_t<_Ty>>;

#if _HAS_CXX20
_EXPORT_STD template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

_EXPORT_STD template <class _Ty>
struct remove_cvref
{
    using type = remove_cvref_t<_Ty>;
};
#endif // _HAS_CXX20
#endif
_STD_END