#pragma once
#ifdef ARDUINO_ARCH_AVR
#define concept constexpr bool
#endif
#ifdef ARDUINO_ARCH_ESP32
#include_next <concepts>
#else
// AVR和SAM并不真正支持concepts。C++17实现为 constexpr bool 变量模板，C++11实现为结构体模板中的 static constexpr bool 成员。
//  <concepts> -*- C++ -*-

// Copyright (C) 2019-2024 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/concepts
 *  This is a Standard C++ Library header.
 *  @ingroup concepts
 */

#ifndef _GLIBCXX_CONCEPTS
#define _GLIBCXX_CONCEPTS 1

#ifdef _GLIBCXX_SYSHDR
#pragma GCC system_header
#endif

#define __glibcxx_want_all
#include <bits/version.h>

#ifdef __cpp_lib_concepts // C++ >= 20 && concepts
/**
 * @defgroup concepts Concepts
 * @ingroup utilities
 *
 * Concepts for checking type requirements.
 */

#include <type_traits>

namespace std _GLIBCXX_VISIBILITY(default)
{
	_GLIBCXX_BEGIN_NAMESPACE_VERSION

	// [concepts.lang], language-related concepts

	namespace __detail
	{
		template <typename _Tp, typename _Up>
		concept __same_as = std::is_same_v<_Tp, _Up>;
	} // namespace __detail

	/// [concept.same], concept same_as
	template <typename _Tp, typename _Up>
	concept same_as = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

	namespace __detail
	{
		template <typename _Tp, typename _Up>
		concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
	} // namespace __detail

	/// [concept.derived], concept derived_from
	template <typename _Derived, typename _Base>
	concept derived_from = __is_base_of(_Base, _Derived) && is_convertible_v<const volatile _Derived *, const volatile _Base *>;

	// [concepts.arithmetic], arithmetic concepts

	template <typename _Tp>
	concept integral = is_integral_v<_Tp>;

	template <typename _Tp>
	concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

	template <typename _Tp>
	concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

	template <typename _Tp>
	concept floating_point = is_floating_point_v<_Tp>;

	namespace __detail
	{
		template <typename _Tp>
		using __cref = const remove_reference_t<_Tp> &;

		template <typename _Tp>
		concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

		template <typename _Tp>
		constexpr bool __destructible_impl = false;

		template <typename _Tp>
		constexpr bool __destructible = __destructible_impl<_Tp>;
		template <typename _Tp>
		constexpr bool __destructible<_Tp &> = true;
		template <typename _Tp>
		constexpr bool __destructible<_Tp &&> = true;
		template <typename _Tp, size_t _Nm>
		constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

	} // namespace __detail

	/// [concept.destructible], concept destructible
	template <typename _Tp>
	concept destructible = __detail::__destructible<_Tp>;

	/// [concept.constructible], concept constructible_from
	template <typename _Tp, typename... _Args>
	concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;
	// 172
	/// [concept.moveconstructible], concept move_constructible
	template <typename _Tp>
	concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;
	// 177
	//  [concept.swappable], concept swappable

	namespace ranges
	{
		/// @cond undocumented
		namespace __swap
		{
			template <typename _Tp>
			void swap(_Tp &, _Tp &) = delete;

			struct _Swap
			{
			private:
			public:
			};
		} // namespace __swap
		/// @endcond

		inline namespace _Cpo
		{
			inline constexpr __swap::_Swap swap{};
		}
	} // namespace ranges
	// 269
	//  [concepts.object], Object concepts

	template <typename _Tp>
	concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp &, _Tp> && swappable<_Tp>;
	// 275
	// 354
	template <typename _Tp>
	concept regular = semiregular<_Tp> && equality_comparable<_Tp>;
	// 357
	//  [concepts.callable], callable concepts

	/// [concept.invocable], concept invocable
	template <typename _Fn, typename... _Args>
	concept invocable = is_invocable_v<_Fn, _Args...>;

	/// [concept.regularinvocable], concept regular_invocable
	template <typename _Fn, typename... _Args>
	concept regular_invocable = invocable<_Fn, _Args...>;

	_GLIBCXX_END_NAMESPACE_VERSION
} // namespace
#endif // __cpp_lib_concepts

#endif /* _GLIBCXX_CONCEPTS */
#endif